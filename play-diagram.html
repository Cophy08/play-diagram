<!DOCTYPE html>
<html lang="en" style="width: 100%; overflow-x: hidden;">
<head>
	<meta charset="utf-8">
	<title>Play Diagram</title>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
	<link href="http://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet" type="text/css">
	<script type="text/javascript" src="js/rinkPlot.js"></script>
	<link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
	<a href="#" id="play" style="text-decoration: none; font-family: Roboto; margin-left: 20px;">Play</a>
	<svg id="rink-svg" style="display: block;"></svg>
	<div id="table" style="display: block;"></div>
	</div>
</body>
<script>

/*
*
* Rink configuration
*
*/

var margin = {top: 30, left: 30, right: 30, bottom: 30};

var rinkWidth = 200;
var rinkHeight = 85;
var rinkRadius = 28;
var ftPerCell = 5;
var cellSize = 20;

var x = d3.scale.linear()
	.domain([0, rinkWidth])
	.range([0, (rinkWidth / ftPerCell) * cellSize]);
var y = d3.scale.linear()
	.domain([0, rinkHeight])
	.range([(rinkHeight / ftPerCell) * cellSize, 0]);

/*
*
* Data
*
*/

// Player data
var playerData = [];
var playerIds = d3.range(1, 10 + 1, 1);
playerIds.forEach(function(p) {
	var colour = "blue";
	if (p > 5) { colour = "red"; }
	playerData.push({
		id: p,
		label: "F" + p,
		colour: colour,
		waypoints: [],
		paths: []
	})
});

// Puck data
var puckWaypoints = [];


/*
*
* Timeline configuration
*
*/
var activeCircleR = 8;
var waypointCircleR = 5;
var timepointCircleR = 4;

var timelineWidth = 900;
var timelineHeight = 40;

var puckSeconds = d3.range(0, 30 + 0.5, 0.5);
var playerSeconds = d3.range(0, 30 + 1, 1);

var tX = d3.scale.ordinal()
	.domain(puckSeconds)
	.rangeRoundPoints([0, timelineWidth], 1);


// Stores the active element in the timeline
// timeline: puck, player
// type: timepoint, waypoint
// player: playerId that owns the timepoint or waypoint
// time: time of the timepoint or waypoint
var activeElement = {
	timeline: null,
	type: null,
	player: null,
	time: null
}

/*
*
* Initialize SVG
*
*/

d3.select("#rink-svg")
	.style("height", (rinkHeight / ftPerCell) * cellSize + margin.top + margin.bottom + "px")
	.style("width", (rinkWidth / ftPerCell) * cellSize + margin.left + margin.right + "px")
	.append("g")
		.attr("id", "rink")
		.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

initRink();
initTimeline();

/*
*
* Start transitions
*
*/

d3.select("#play").on("click", function() {
	d3.selectAll("g.player").selectAll("g.marker").each(function(d) {
		translatePlayer(d3.select(this), d, 0);
	});
});

function translatePlayer(element, data, idx) {
	if (idx < data.paths.length) {
		var animPlayerGroup = d3.selectAll("g.player").filter(function(d) { return d.id === data.id; });
		var animMarker = animPlayerGroup.select("g.marker");
		var animPath = animPlayerGroup.selectAll("path").filter(function(d) { return d.order === idx; });
		animMarker.transition()
			.duration(function(d) { return d.paths[idx].duration * 1000; })
			.ease("linear")
			.attrTween("transform", translateAlong(animPath.node()))
			.each("end", function(d) {
				translatePlayer(d3.select(this), d, idx + 1);
			});
	}
}

// Returns an attrTween for translating along the specified path element.
function translateAlong(path) {
	var l = path.getTotalLength();
	return function(d, i, a) {
		return function(t) {
		  var p = path.getPointAtLength(t * l);
		  return "translate(" + p.x + "," + p.y + ")";
		};
	};
}

function initTimeline() {

	// Create the puck row in the timeline table
	var rows = d3.select("#table").selectAll("div.puck.row")
		.data([puckWaypoints])
		.enter().append("div")
			.attr("id", "puck")
			.attr("class", "puck row");
	rows.append("div")
		.attr("class", "give-puck cell");
	rows.append("div")
		.attr("class", "label cell")
		.text("Puck");
	rows.append("div")
		.attr("class", "colour-picker cell");
	rows.append("div")
		.attr("class", "timeline cell");

	// Create the player rows in the timeline table
	var rows = d3.select("#table").selectAll("div.player.row")
		.data(playerData)
		.enter().append("div")
			.attr("id", function(d) { return "player-" + d.id; })
			.attr("class", "player row");

	rows.append("div")
		.attr("class", "give-puck cell")
		.text("Gets puck");
	rows.append("div")
		.attr("class", "label cell");
	rows.append("div")
		.attr("class", "colour-picker cell");
	rows.append("div")
		.attr("class", "timeline cell");

	// Append listeners to the "give puck" cells
	d3.select("#table").selectAll(".player.row").selectAll("div.give-puck.cell").on("click", function(d) {
		if (activeElement.timeline === "puck") {
			if (activeElement.type === "timepoint" || activeElement.type === "waypoint") {
				// If a puck timepoint is active, then clicking a player creates a new puck waypoint on the player
				// If a puck waypoint is active, then clicking on a player updates the waypoint to the player
				updatePuckWaypoint("player", activeElement.time, null, null, d.id);
				closePicker();
			} else {
				// TODO: are there other cases?
			}
		} else {
			console.log("Can only give puck to a player when a puck timepoint is selected!");
		}
	});


	// Append player label text fields
	d3.select("#table").selectAll(".player.row").selectAll("div.label").append("input")
		.attr("id", function(d) { return "label-" + d.id; })
		.attr("type", "text")
		.attr("size", 5)
		.attr("maxlength", 3)
		.property("value", function(d) { return d.label; })
		.on("blur", function(d) {
			// Update player label when text field loses focus - only update if the value has changed
			var newLabel = document.getElementById("label-" + d.id).value;
			if (d.label !== newLabel) { updatePlayerLabel(d.id, newLabel); }
		});

	// Append colour pickers and listeners
	d3.select("#table").selectAll("div.colour-picker").append("svg")
		.attr("class", "colour-picker")
		.style("height", timelineHeight + "px")
		.attr("width", (2 * timepointCircleR) + "px")
	d3.select("#table").selectAll("svg.colour-picker").append("circle")
		.attr("class", "colour-picker")
		.attr("cx", timepointCircleR)
		.attr("cy", timelineHeight / 3)
		.attr("r", timepointCircleR)
		.style("fill", function(d) {
			if (!d.colour) { return "black"; }
			else { return d.colour; }
		})
		.on("click", function(d) {
			var newColour = "blue";
			if (d.colour === "blue") { newColour = "red"; }
			updatePlayerColour(d.id, newColour);
		});

	// Append timeline svgs and timepoints
	var timelines = d3.select("#table").selectAll("div.timeline")
		.append("svg")
			.attr("class", "timeline")
			.attr("height", timelineHeight + "px")
			.attr("width", timelineWidth + "px");

	// Append a circle to indicate the active timepoint or waypoint; these should be rendered behind the actual timepoints
	timelines.append("line")
		.attr("class", "baseline")
		.attr("x1", tX(playerSeconds[0]))
		.attr("x2", tX(playerSeconds[playerSeconds.length - 1]))
		.attr("y1", timelineHeight / 3)
		.attr("y2", timelineHeight / 3);
	timelines.append("circle")
		.attr("class", "active")
		.attr("r", 0)
		.attr("cy", timelineHeight / 3)
		.style("visibility", "hidden");

	// Append a delete link
	var bW = 42;
	var bH= 15;
	var buttons = timelines.append("g")
		.attr("class", "button delete");
	buttons.append("rect")
		.attr("x", -bW / 2)
		.attr("y", timelineHeight - bH)
		.attr("rx", 2)
		.attr("ry", 2)
		.attr("width", bW)
		.attr("height", bH)
		.style("visibility", "hidden");
	buttons.append("text")
		.attr("x", 0)
		.attr("y", timelineHeight - bH / 2 + 1)
		.style("visibility", "hidden")
		.text("DELETE");

	// Delete listeners for player waypoints and puck waypoints
	d3.select("#table").selectAll(".player.row").selectAll(".button.delete").on("click", function() {
		removePlayerWaypoint(activeElement.player, activeElement.time);
		closePicker();
	});
	d3.select("#table").select(".puck.row").select(".button.delete").on("click", function() {
		removePuckWaypoint(activeElement.time);
		closePicker();
	});

	// Append puck timepoints
	d3.select("#table").selectAll(".puck.row").select("svg.timeline").selectAll("circle.timepoint")
		.data(puckSeconds)
		.enter().append("circle")
			.attr("class", "timepoint");

	// Append player timepoints
	d3.select("#table").selectAll(".player.row").select("svg.timeline").selectAll("circle.timepoint")
		.data(playerSeconds)
		.enter().append("circle")
			.attr("class", "timepoint");

	// Update all timepoints
	d3.select("#table").selectAll(".row").selectAll("circle.timepoint")
		.attr("cy", timelineHeight / 3)
		.attr("cx", function(d) { return tX(d); })
		.attr("r", timepointCircleR);

	initPlayerTimelineListeners();
	initPuckTimelineListeners();

	// Append a dot in the rink-svg for user to pick skater position
	// Draw the rectangle above the dot so that all mousemove events register
	d3.select("#rink").append("circle")
		.attr("id", "picker-marker")
		.attr("cx", 0)
		.attr("cy", 0)
		.attr("r", activeCircleR)
		.style("visibility", "hidden");
	d3.select("#rink").append("rect")
		.attr("id", "picker-mask")
		.attr("width", x.range()[1])
		.attr("height", y.range()[0])
		.attr("rx", x(rinkRadius))
		.attr("ry", y(0) - y(rinkRadius))
		.style("visibility", "hidden");
}

function initPuckTimelineListeners() {
	d3.select(".puck.row").select("svg.timeline").selectAll("circle.timepoint").on("click", function(d) {
		if (activeElement.timeline === "puck" && activeElement.type === "timepoint" && activeElement.time === d) {
			// If the currently active timepoint is clicked, close the picker, which will also clear the active element\
			closePicker();
		} else if (activeElement.timeline == null || activeElement.type === "timepoint") {
			// If there's no active element, set it to the clicked timepoint
			// Or if the user clicks on a timepoint that isn't the currently active timepoint, make the clicked timepoint active
			// This includes switching from an active player timepoint to an active puck timepoint
			activeElement.timeline = "puck";
			activeElement.type = "timepoint";
			activeElement.time = d;
			activeElement.player = null;

			// Open the picker for the new active timepoint
			highlightActiveElement();
			openPicker();
		} else if (activeElement.type === "waypoint") {
			// If a waypoint is currently active, then clicking a timepoint will transfer the waypoint's x and y positions to the clicked timepoint's time
			// Get the currently active waypoint's x and y positions
			var activeWaypointData = puckWaypoints.filter(function(w) { return w.t === activeElement.time; })[0];

			// Add waypoint to puckWaypoints; remove the old waypoint from puckWaypoints
			updatePuckWaypoint(activeWaypointData.type, d, activeWaypointData.x, activeWaypointData.y, null);
			removePuckWaypoint(activeElement.time);

			// Close the picker, which will also clear the active element
			closePicker();
		}
	});
}

// Listeners for waypoints
function appendPuckWaypointListeners() {
	d3.select(".puck.row").selectAll("circle.waypoint").on("click", function(d) {
		if (activeElement.timeline === "player") {
			// Clicking a puck waypoint does nothing if a player timeline or waypoint is selected
		} else if (activeElement.type === "waypoint" && activeElement.time === d.t) {
			// If the currently active waypoint is clicked, then close the picker, which will also clear the active element
			closePicker();
		} else if (activeElement.timeline == null) {
			// If there's no active element, set it to the clicked waypoint
			activeElement.timeline = "puck";
			activeElement.type = "waypoint";
			activeElement.time = d.t;
			activeElement.player = null;

			// Highlight the active element and open picker
			highlightActiveElement();
			openPicker();
		}
		// In any other case, clicking a waypoint does nothing. This includes:
		// If a waypoint is active, and the user clicks on another waypoint
		// If a timepoint is active, and the user clicks on a waypoint
	});
}

// Listeners for timepoints
function initPlayerTimelineListeners() {
	d3.selectAll(".player.row").selectAll("svg.timeline").selectAll("circle.timepoint").on("click", function(d) {

		var clickedPlayerId = this.parentNode.parentNode.parentNode.__data__.id;

		if (activeElement.timeline === "puck" && activeElement.type === "waypoint") {
			// Clicking a player timepoint does nothing if a puck waypoint is selected
		} else if (activeElement.timeline === "player" && activeElement.type === "timepoint" && activeElement.player === clickedPlayerId && activeElement.time === d) {
			// If the currently active timepoint is clicked, then close the picker, which will also clear the active element
			closePicker();
		} else if (activeElement.timeline == null || activeElement.type === "timepoint") {
			// If there's no active element, set it to the clicked timepoint
			// Or if the user clicks on a timepoint that isn't the currently active timepoint, make the clicked timepoint active
			// This includes switching from an active puck timepoint to an active player timepoint
			activeElement.timeline = "player";
			activeElement.type = "timepoint";
			activeElement.time = d;
			activeElement.player = clickedPlayerId;

			// Open the picker for the new active timepoint
			highlightActiveElement();
			openPicker();
		} else if (activeElement.type === "waypoint") {
			// If a waypoint is currently active, then clicking a timepoint will transfer the waypoint's x and y positions to the clicked timepoint's player and time
			// Get the currently active waypoint's x and y positions
			var activeWaypointData = playerData
				.filter(function(p) { return p.id === activeElement.player; })[0].waypoints
				.filter(function(w) { return w.t === activeElement.time; })[0];

			// Add waypoint to the clickedPlayer; remove waypoint from the activeElement player
			updatePlayerWaypoint(clickedPlayerId, d, activeWaypointData.x, activeWaypointData.y);
			removePlayerWaypoint(activeElement.player, activeElement.time);

			// Close the picker, which will also clear the active element
			closePicker();
		}
	});
}

// Listeners for waypoints
function appendPlayerWaypointListeners() {
	d3.selectAll(".player.row").selectAll("svg.timeline").selectAll("circle.waypoint").on("click", function(d) {
		var clickedPlayerId = this.parentNode.parentNode.parentNode.__data__.id;
		if (activeElement.timeline === "puck") {
			// Clicking a player waypoint does nothing if a puck timeline or waypoint is selected
		} else if (activeElement.type === "waypoint" && activeElement.player === clickedPlayerId && activeElement.time === d.t) {
			// If the currently active waypoint is clicked, then close the picker, which will also clear the active element
			closePicker();
		} else if (activeElement.timeline == null) {
			// If there's no active element, set it to the clicked waypoint
			activeElement.timeline = "player";
			activeElement.type = "waypoint";
			activeElement.time = d.t;
			activeElement.player = clickedPlayerId;

			// Highlight the active element and open picker
			highlightActiveElement();
			openPicker();
		}
		// In any other case, clicking a waypoint does nothing. This includes:
		// If a waypoint is active, and the user clicks on another waypoint
		// If a timepoint is active, and the user clicks on a waypoint
	});
}

// Highlights the timepoint in the timeline of the specified player id
function highlightActiveElement() {
	clearActiveElementHighlights();
	var timelineSvgs;
	if (activeElement.timeline === "player") {
		timelineSvgs = d3.selectAll(".row.player").selectAll("svg.timeline").filter(function(d) { return d.id === activeElement.player; })
	}
	else if (activeElement.timeline === "puck") {
		timelineSvgs = d3.select(".row.puck").select("svg.timeline");
	}

	timelineSvgs.select("circle.active")
			.attr("cx", tX(activeElement.time))
			.attr("r", function() {
				// If the active element is a waypoint, the starting radius for circle.active should be the waypoint circle radius
				// Otherwise, it's going to feel like there's a delay because circle.active's smaller sizes will be obscured by the waypoint
				if (activeElement.type === "waypoint") { return waypointCircleR; }
				else { return 0; }
			})
			.style("visibility", "visible")
			.transition()
				.duration(function() {
					if (activeElement.type === "waypoint") { return 250 * (waypointCircleR / activeCircleR); }
					else { return 250; }
				})
				.ease("ease-out")
				.attr("r", activeCircleR);

	// Display the delete button
	if (activeElement.type === "waypoint") {
		if (activeElement.timeline === "player") {
			timelineSvgs = timelineSvgs.filter(function(d) { return d.id === activeElement.player; })
		}
		timelineSvgs.selectAll(".button.delete").selectAll("*")
			.attr("transform", "translate(" + tX(activeElement.time) + ",0)")
			.style("visibility", "visible");
	}
}

// Hide active highlight and delete action in timelines
function clearActiveElementHighlights() {
	d3.selectAll("svg.timeline").filter(function(d) { return d.id !== activeElement.player; })
		.selectAll("circle.active")
			.transition()
				.ease("ease-in")
				.attr("r", 0)
				.each("end", function() { d3.select(this).style("visibility", "hidden"); });
	d3.selectAll(".button.delete").selectAll("*")
		.style("visibility", "hidden");
}

function clearActiveElement() {
	activeElement.timeline = null;
	activeElement.type = null;
	activeElement.time = null;
	activeElement.player = null;
	clearActiveElementHighlights();
}

function openPicker() {
	// Make picker elements visible
	d3.selectAll("#picker-marker, #picker-mask")
		.attr("class", "active")
		.style("visibility", "visible");
	d3.select("#picker-marker")
		.attr("cx", -100)
		.attr("cy", -100);

	// Move the picker marker; snap to the closest whole foot
	var pxPerFt = cellSize / ftPerCell;
	var mPos, mX, mY;
	d3.select("#picker-mask").on("mousemove", function() {
		mPos = d3.mouse(this);
		mX = Math.round(mPos[0] / pxPerFt) * pxPerFt;
		mY = Math.round(mPos[1] / pxPerFt) * pxPerFt;
		d3.select("#picker-marker").attr("cx", mX)
			.attr("cy", mY);
	});

	// Update waypoint data with the picked position, then close the picker
	d3.select("#picker-mask").on("click", function() {
		if (activeElement.timeline === "player") {
			updatePlayerWaypoint(activeElement.player, activeElement.time, Math.round(x.invert(mX)), Math.round(y.invert(mY)));
		} else if (activeElement.timeline === "puck") {
			updatePuckWaypoint("position", activeElement.time, Math.round(x.invert(mX)), Math.round(y.invert(mY)), null);
		}
		closePicker();
	});
}

// Remove listeners and hide picker
function closePicker() {
	// Hide picker elements on rink
	d3.select("#picker-mask").on("mousemove", null);
	d3.select("#picker-mask").on("click", null);
	d3.selectAll("#picker-marker, #picker-mask")
		.attr("class", "")
		.style("visibility", "hidden");

	// Clear active element
	clearActiveElement();
}

function removePlayerWaypoint(player, t) {
	// Check if a waypoint for the specified time already exists. If it does, get its index
	var playerToUpdate = playerData.filter(function(d) { return d.id === player; })[0];
	var existingWaypointIdx = -1;
	var i = 0;
	while (existingWaypointIdx < 0 && i < playerToUpdate.waypoints.length) {
		if (playerToUpdate.waypoints[i].t === t) { existingWaypointIdx = i; }
		else { i++; }
	}

	// Remove the waypoint, then update path data and rink
	if (existingWaypointIdx >= 0) { playerToUpdate.waypoints.splice(existingWaypointIdx, 1); }
	generateDStrings(playerToUpdate.id - 1);
	updateRink();
}

function updatePlayerWaypoint(player, t, x, y) {

	var playerToUpdate = playerData.filter(function(d) { return d.id === player; })[0];

	// Check if a waypoint for the specified time already exists. If it does, get its index
	var existingWaypointIdx = -1;
	var i = 0;
	while (existingWaypointIdx < 0 && i < playerToUpdate.waypoints.length) {
		if (playerToUpdate.waypoints[i].t === t) { existingWaypointIdx = i; }
		else { i++; }
	}

	// Add or update waypoint, then update path data and rink
	if (existingWaypointIdx >= 0) {
		playerToUpdate.waypoints[existingWaypointIdx] = {t: t, x: x, y: y};
	} else {
		playerToUpdate.waypoints.push({t: t, x: x, y: y});
		playerToUpdate.waypoints = playerToUpdate.waypoints.sort(function(a, b) { return a.t - b.t; });
	}
	generateDStrings(playerToUpdate.id - 1);
	updateRink();
}

function removePuckWaypoint(t) {
	// Check if a waypoint for the specified time already exists. If it does, get its index
	var existingWaypointIdx = -1;
	var i = 0;
	while (existingWaypointIdx < 0 && i < puckWaypoints.length) {
		if (puckWaypoints[i].t === t) { existingWaypointIdx = i; }
		else { i++; }
	}

	// Remove the waypoint, then update path data and rink
	if (existingWaypointIdx >= 0) { puckWaypoints.splice(existingWaypointIdx, 1); }
	updateRink();
}

function updatePuckWaypoint(type, t, x, y, player) {

	// Check if a waypoint for the specified time already exists. If it does, get its index
	var existingWaypointIdx = -1;
	var i = 0;
	while (existingWaypointIdx < 0 && i < puckWaypoints.length) {
		if (puckWaypoints[i].t === t) { existingWaypointIdx = i; }
		else { i++; }
	}

	// Add or update waypoint, then update path data and rink
	if (existingWaypointIdx >= 0) {
		puckWaypoints[existingWaypointIdx] = { type: type, t: t, x: x, y: y, player: player };
	} else {
		puckWaypoints.push({ type: type, t: t, x: x, y: y, player: player });
		puckWaypoints = puckWaypoints.sort(function(a, b) { return a.t - b.t; });
	}
	updateRink();
}

function updatePlayerColour(player, newColour) {
	var playerToUpdate = playerData.filter(function(d) { return d.id === player; })[0];
	playerToUpdate.colour = newColour;
	updateRink();
}

function updatePlayerLabel(player, newLabel) {
	var playerToUpdate = playerData.filter(function(d) { return d.id === player; })[0];
	playerToUpdate.label = newLabel;
	updateRink();
}

function initRink() {
	// Append subgroups for rink to control layering
	["rink-map", "players", "puck"].forEach(function(name) {
		d3.select("#rink").append("g").attr("id", name);
	});

	// Append and style rink
	var drawRinkMap = new RINK_MAP({parent: d3.select("#rink-map"), fullRink: true, desiredWidth: (rinkHeight / ftPerCell) * cellSize, horizontal: true});
	drawRinkMap();
	styleRink();

	// Append groups and subgroups for each player to control layering
	var players = d3.select("#players").selectAll("g.player")
		.data(playerData, function(d) { return d.id; })
		.enter().append("g")
			.attr("class", "player");

	["paths", "waypoints", "marker"].forEach(function(name) {
		players.append("g").attr("class", name);
		d3.select("#puck").append("g").attr("class", name);
	});

	// Append marker elements
	// Markers will be positioned as a group with transformations, so hardcode circle and text positions
	d3.select("#players").selectAll("g.marker")
		.append("circle")
			.attr("cx", 0)
			.attr("cy", -1) // To better center circle on player number
			.attr("r", 10)
			.style("stroke-opacity", 0);
	d3.select("#players").selectAll("g.marker")
		.append("text")
			.attr("x", 0)
			.attr("y", 0);
}

function updateRink() {

	// Bind updated data to player groups
	// Since playerData was initialized to always have 10 players, player groups will never enter or exit
	var players = d3.select("#players").selectAll("g.player")
		.data(playerData, function(d) { return d.id; });
	players.attr("class", function(d) { return "player " + d.colour; });

	// Update paths in the path groups and points in the point group
	// Using select() propagates the updated g.player data to g.paths: http://stackoverflow.com/questions/10129432/inheritance-in-data-joins
	var paths = players.select("g.paths").selectAll("path.skater")
		.data(function(d) { return d.paths; }, function(p) { return p.order + p.dString; });
	paths.exit().remove();
	paths.enter().append("path")
		.attr("class", "skater");
	paths.attr("d", function(d) { return d.dString; });

	// Player waypoints
	var waypoints = players.select("g.waypoints").selectAll("text.waypoint")
		.data(function(d) { return d.waypoints; }, function(w) { return w.t; })
	waypoints.exit().remove();
	waypoints.enter().append("text")
		.attr("class", "waypoint");

	// Puck waypoints
	waypoints = d3.select("#puck").select("g.waypoints").selectAll("text.waypoint")
		.data(puckWaypoints.filter(function(d) { return d.type === "position"; }), function(d) { return d.t; });
	waypoints.exit().remove();
	waypoints.enter().append("text")
		.attr("class", "waypoint");

	// Player and puck waypoints
	waypoints = d3.select("#rink").selectAll("text.waypoint");
	waypoints.attr("x", function(d) { return x(d.x); })
		.attr("y", function(d) { return y(d.y); })
		.text(function(d) { return d.t; });

	// Update markers - hide markers for players with no waypoints
	var markers = players.select("g.marker");
	markers.style("visibility", function(d) {
			if (d.waypoints.length === 0) { return "hidden"; }
			else { return "visible"; }
		})
	markers.select("text").text(function(d) { return d.label; });

	// Only update position of players with 1 or more waypoints
	markers.filter(function(d) { return d.waypoints.length > 0; })
		.attr("transform", function(d) { return "translate(" + x(d.waypoints[0].x) + "," + y(d.waypoints[0].y) + ")"; });

	/*
	*
	* Update timeline
	*
	*/

	// Bind data to player waypoints
	var rows = d3.select("#table").selectAll("div.player.row")
		.data(playerData, function(d) { return d.id; });
	var waypoints = rows.select("div.timeline").select("svg").selectAll("circle.waypoint")
		.data(function(d) { return d.waypoints; }, function(w) { return w.t; });
	waypoints.exit().transition()
		.attr("r", 0)
		.each("end", function() { d3.select(this).remove(); });
	waypoints.enter().append("circle")
		.attr("class", "waypoint")
		.attr("r", 0)
		.transition().ease("linear").attr("r", waypointCircleR);

	// Bind data to puck waypoints - only position waypoints are displayed in the rink
	waypoints = d3.select("#table").selectAll("div.puck.row").select("svg.timeline").selectAll("circle.waypoint")
		.data(puckWaypoints, function(d) { return d.t; });
	waypoints.exit().transition()
		.attr("r", 0)
		.each("end", function() { d3.select(this).remove(); });
	waypoints.enter().append("circle")
		.attr("class", "waypoint")
		.attr("r", 0)
		.transition().ease("linear").attr("r", waypointCircleR);

	// Update all waypoints
	d3.select("#table").selectAll("svg.timeline").selectAll("circle.waypoint")
		.attr("cx", function(d) { return tX(d.t); })
		.attr("cy", timelineHeight / 3);

	// Add listeners for waypoints
	appendPlayerWaypointListeners();
	appendPuckWaypointListeners();

	var labels = d3.select("#table").selectAll("div.puck.row").select("svg.timeline").selectAll("text.waypoint")
		.data(puckWaypoints.filter(function(d) { return d.type === "player"; }), function(d) { return d.t; });
	labels.exit().remove();
	labels.enter().append("text")
		.attr("class", "waypoint")
		.attr("y", 10);
	labels.attr("x", function(d) { return tX(d.t); })
		.text(function(d) { return d.player; });

	// Update colour pickers
	d3.select("#table").selectAll("svg.colour-picker").select("circle.colour-picker")
		.style("fill", function(d) { return d.colour; });
};

function generateDStrings(playerIdx) {

	// Create paths from waypoints
	paths = [];
	for (var i = 0; i < playerData[playerIdx].waypoints.length - 1; i++) {
		var nextPoint = [];
		if (i < playerData[playerIdx].waypoints.length - 2) {
			nextPoint = [playerData[playerIdx].waypoints[i + 2].x, playerData[playerIdx].waypoints[i + 2].y];
		}
		paths.push({
			order: i,
			start: [playerData[playerIdx].waypoints[i].x, playerData[playerIdx].waypoints[i].y],
			end: [playerData[playerIdx].waypoints[i + 1].x, playerData[playerIdx].waypoints[i + 1].y],
			next: nextPoint,
			duration: playerData[playerIdx].waypoints[i + 1].t - playerData[playerIdx].waypoints[i].t
		});
	}
	playerData[playerIdx].paths = paths;

	// Create the string for each path's d attribute
	for (var i = 0; i < playerData[playerIdx].paths.length; i++) {

		var ctrlPt = [x(playerData[playerIdx].paths[i].end[0]), y(playerData[playerIdx].paths[i].end[1])];

		if (playerData[playerIdx].paths[i].start[0] === playerData[playerIdx].paths[i].end[0] && playerData[playerIdx].paths[i].start[1] === playerData[playerIdx].paths[i].end[1]) {
			// Keep the ctrlPt at the endPt if the player is stationary
		} else if (playerData[playerIdx].paths[i].next.length === 2) {

			// Increasing delta will increase smoothing by increasing the ctrlPt's offset
			var delta = 20;

			var rise = y(playerData[playerIdx].paths[i].next[1]) - y(playerData[playerIdx].paths[i].end[1]);
			rise *= -1; // Adjust rise since higher y values are plotted lower
			var run = x(playerData[playerIdx].paths[i].next[0]) - x(playerData[playerIdx].paths[i].end[0]);
			var slope = rise / run;

			if (slope === 0) {
				if (run >= 0) {
					// If player will skate right, then ctrlPt is left
					ctrlPt[0] -= delta;
				} else {
					// If player will skate left, then ctrlPt is right
					ctrlPt[0] += delta;
				}
			} else if (slope == Number.POSITIVE_INFINITY || slope == Number.NEGATIVE_INFINITY) {
				if (rise >= 0) {
					// If player skates up, then ctrlPt is down
					ctrlPt[1] += delta;
				} else {
					// If player skates down, then ctrlPt is up
					ctrlPt[1] -= delta;
				}
			} else {

				// To keep the ctrlPt close, deltaX and deltaY (the ctrlPt's offset) should not be larger than delta while maintaining the slope value
				var deltaX, deltaY;
				if (Math.abs(slope) <= 1) {
					deltaX = delta;
					deltaY = delta * Math.abs(slope);
				} else {
					deltaX = delta / Math.abs(slope);
					deltaY = delta;
				}

				if (slope > 0 && run >= 0) {
					// If player will skate up and right, then ctrlPt is down and left
					ctrlPt[0] -= deltaX;
					ctrlPt[1] += deltaY;
				} else if (slope > 0 && run < 0) {
					// If player will skate down and left, then ctrlPt is up and right
					ctrlPt[0] += deltaX;
					ctrlPt[1] -= deltaY;
				} else if (slope < 0 && run >= 0) {
					// If player will skate down and right, then ctrlPt is up and left
					ctrlPt[0] -= deltaX;
					ctrlPt[1] -= deltaY;
				} else if (slope < 0 && run < 0) {
					// If player will skate up and left, then ctrlPt is down and right
					ctrlPt[0] += deltaX;
					ctrlPt[1] += deltaY;
				}
			}

			// Check if the ctrlPt is in the rink - if it isn't set the ctrlPt to the endpoint
			if (isPointInRink(ctrlPt) === false ) {
				ctrlPt = [x(playerData[playerIdx].paths[i].end[0]), y(playerData[playerIdx].paths[i].end[1])];
			}

			// To check where the ctrlPt is located
			// d3.select("#rink").append("circle")
			// 	.attr("class", "ctrlPt")
			// 	.attr("cx", ctrlPt[0])
			// 	.attr("cy", ctrlPt[1])
			// 	.attr("r", 2)
			// 	.attr("fill", "gold");
		}
		//d3.selectAll("circle.ctrlPt").remove();

		var dString = "M" + x(playerData[playerIdx].paths[i].start[0]) + "," + y(playerData[playerIdx].paths[i].start[1]);
		dString += " S" + ctrlPt[0] + "," + ctrlPt[1];
		dString += " " + x(playerData[playerIdx].paths[i].end[0]) + "," + y(playerData[playerIdx].paths[i].end[1]);
		playerData[playerIdx].paths[i].dString = dString;
	}

	// Check if a given point [x, y] is within the rink - coordinates should already be scaled to pixels (not feet)
	function isPointInRink(point) {
		var isInRink = false;
		// Check if point is within the 4 circles
		// Centers of the top-left, bottom-left, top-right, and bottom-right rink arcs
		var centres = [];
		centres[0] = [x(rinkRadius), y(rinkHeight) + y(rinkRadius)];
		centres[1] = [x(rinkRadius), y(0) - y(rinkRadius)];
		centres[2] = [x(rinkWidth) - x(rinkRadius), y(rinkHeight) + y(rinkRadius)];
		centres[3] = [x(rinkWidth) - x(rinkRadius), y(0) - y(rinkRadius)];
		var i = 0;
		while (!isInRink && i < centres.length) {
			var a2 = Math.pow(point[0] - centres[i][0], 2);
			var b2 = Math.pow(point[1] - centres[i][1], 2);
			var c2 = Math.pow(x(rinkRadius), 2);
			if (a2 + b2 < c2) { isInRink = true; }
			else { i++; }
		};
		// Check if point is in the rectangle that goes from one end of the rink to the other
		if (!isInRink) {
			if (point[0] > x(0) && point[0] < x(rinkWidth) && point[1] > y(rinkHeight) + y(rinkRadius) && point[1] < y(0) - y(rinkRadius)) {
				isInRink = true;
			}
		}
		// Check if point is in the rectangle that goes from one side (where benches are) of the rink to the other (where penalty boxes are)
		if (!isInRink) {
			if (point[0] > x(0) + x(rinkRadius) && point[0] < x(rinkWidth) - x(rinkRadius) && point[1] > y(rinkHeight) && point[1] < y(0)) {
				isInRink = true;
			}
		}
		return isInRink;
	}
}

/*
*
* Updates styling from rinkPlot.js
*
*/

function styleRink() {

	// Remove translation
	var rinkMap = d3.select("#rink-map");
	rinkMap.select("g.zones")
		.attr("transform", "");

	// Make rink monochrome
	var rinkStroke = "#ccc";
	var rinkFill = "#ebebeb";
	rinkMap.select("g.zones").selectAll("rect")
		.style("fill", rinkFill)
	rinkMap.select("g.zones").selectAll("rect.red-line")
		.style("fill", rinkStroke)
	rinkMap.select("g.zones").selectAll("path, line, circle")
		.style("stroke", rinkStroke);
	rinkMap.select("g.zones").selectAll("circle.red-line")
		.style("stroke", "none")
		.style("fill", rinkFill);
	rinkMap.select("g.zones").selectAll("path.goal-crease")
		.style("stroke", rinkStroke)
		.style("fill", "none");
	rinkMap.selectAll("path.rink-face, circle.red-faceoff")
		.style("fill", "none");

	// Hide the original half rink-faces from rinkPlot.js because it has a line where the 2 halves meet
	rinkMap.selectAll(".rink-face")
		.style("stroke", "none");

	// Redraw a full rink rink-face for a neat outline
	rinkMap.select("g.zones")
		.append("rect")
			.attr("width", x.range()[1])
			.attr("height", y.range()[0])
			.attr("rx", x(rinkRadius))
			.attr("ry", y(0) - y(rinkRadius))
			.style("fill", "none")
			.style("stroke", rinkStroke);
}
</script>
</html>