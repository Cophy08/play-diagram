<!DOCTYPE html>
<html lang="en" style="width: 100%; overflow-x: hidden;">
<head>
	<meta charset="utf-8">
	<title>Play Diagram</title>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
	<link href="http://fonts.googleapis.com/css?family=Roboto:400,500,700,900" rel="stylesheet" type="text/css">
</head>
<body>
	<svg></svg>
</body>
<script>
var rinkWidth = 200;
var rinkHeight = 85;
var ftPerCell = 5;
var cellSize = 20;

var margin = {top: 30, left: 30, right: 30, bottom: 30};

var x = d3.scale.linear()
	.domain([0, rinkWidth])
	.range([0, (rinkWidth / ftPerCell) * cellSize]);
var y = d3.scale.linear()
	.domain([0, rinkHeight])
	.range([(rinkHeight / ftPerCell) * cellSize, 0]);

/*
*
* Initialize layout
*
*/

d3.select("svg")
	.style("height", (rinkHeight / ftPerCell) * cellSize + margin.top + margin.bottom + "px")
	.style("width", (rinkWidth / ftPerCell) * cellSize + margin.left + margin.right + "px")
	.style("margin", "20px")
	.style("background", "#fff")
	.style("font-family", "Roboto, sans-serif")
	.style("font-size", "12px")
	.style("font-weight", "500");

var rink = d3.select("svg").append("g")
	.attr("id", "rink")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
rink.append("g")
	.attr("id", "h-rules");
rink.append("g")
	.attr("id", "v-rules");


/*
*
* Append grid
*
*/

var gridlines = rink.select("#h-rules").selectAll("g")
	.data(d3.range(y.domain()[0], y.domain()[1] + ftPerCell, ftPerCell))
	.enter().append("g");
gridlines.append("line")
	.attr("x1", function() { return d3.min(x.range()); })
	.attr("x2", function() { return d3.max(x.range()); })
	.attr("y1", function(d) { return y(d); })
	.attr("y2", function(d) { return y(d); })
	.attr("stroke", "#ddd")
	.attr("stroke-width", 1)
	.attr("y-coord", function(d) { return d; });
gridlines.append("text")
	.attr("y", function(d) { return y(d); })
	.attr("x", -10)
	.style("alignment-baseline", "middle")
	.style("text-anchor", "end")
	.style("font-size", "8px")
	.style("fill", "#aaa")
	.text(function(d) { return d; });

gridlines = rink.select("#v-rules").selectAll("g")
	.data(d3.range(x.domain()[0], x.domain()[1] + ftPerCell, ftPerCell))
	.enter().append("g");
gridlines.append("line")
	.attr("x1", function(d) { return x(d); })
	.attr("x2", function(d) { return x(d); })
	.attr("y1", function() { return d3.min(y.range()); })
	.attr("y2", function() { return d3.max(y.range()); })
	.attr("stroke-width", 1)
	.attr("stroke", function(d) {
		if (d === 100 || d === 10 || d === 190) {
			return "#aaa";
		} else if (d === 65 || d === 135 ) {
			return "#aaa"
		} else {
			return "#ddd";
		}
	})
	.attr("x-coord", function(d) { return d; });
gridlines.append("text")
	.attr("y", y.range()[0] + 20)
	.attr("x", function(d) { return x(d); })
	.style("text-anchor", "middle")
	.style("font-size", "8px")
	.style("fill", "#aaa")
	.text(function(d) { return d; });

/*
*
* Player data
*
*/

var playerData = [];

playerData.push({
	player: "81",
	colour: "red",
	waypoints: [[0,20,80],[1.5,30,60],[3,10,30],[5,60,30],[7,150,60],[10,160,30]]
});

playerData.push({
	player: "42",
	colour: "red",
	waypoints: [[0,10,42],[2,20,23],[10,180,80]]
});

playerData.push({
	player: "21",
	colour: "red",
	waypoints: [[0,12,22],[1,15,10],[10,180,30]]
});

// Convert waypoint array elements into properties
playerData.forEach(function(p) {
	p.waypoints = p.waypoints.map(function(w) {
		return {
			t: w[0],
			x: w[1],
			y: w[2]
		};
	});

	paths = [];
	for (var i = 0; i < p.waypoints.length - 1; i++) {

		var nextPoint = [];
		if (i < p.waypoints.length - 2) {
			nextPoint = [p.waypoints[i + 2].x, p.waypoints[i + 2].y];
		}

		paths.push({
			order: i,
			start: [p.waypoints[i].x, p.waypoints[i].y],
			end: [p.waypoints[i + 1].x, p.waypoints[i + 1].y],
			next: nextPoint,
			duration: p.waypoints[i + 1].t - p.waypoints[i].t
		});
	}
	p.paths = paths;
});

// Player with puck
var targets = ["81", "42", "21", "42", "81", "r-goal"];
var delays = [0, 1000, 1000, 2000, 2000, 2000];

/*
*
* Append players and paths
*
*/

var players = rink.selectAll("g.player")
	.data(playerData)
	.enter().append("g")
		.attr("class", "player");

var paths = players.selectAll("path")
	.data(function(d) { return d.paths; })
	.enter().append("path")
		.attr("d", function(d) {
			var start = x(d.start[0]) + "," + y(d.start[1]);
			var end = x(d.end[0]) + "," + y(d.end[1]);
			var smoother = [x(d.end[0]), y(d.end[1])];

			if (d.next.length === 2) {

				var rise = y(d.next[1]) - y(d.end[1]);
				var run = x(d.next[0]) - x(d.end[0]);
				var slope = rise / run;

				var maxFactor = 0.1;
				var maxDelta = 40000;

				var isRisePositive = true;
				if (rise < 0) isRisePositive = false;

				var isRunPositive = true;
				if (run < 0) isRunPositive = false;


				if (slope >= 1) {
					rise = 10;
					run = rise / slope;
				} else {
					run = 10;
					rise = run * slope;

					if (!isRisePositive) rise = rise * -1;
				}

				if (slope < 0) rise *= -1;

				if (!isRunPositive) run *= -1;

				// Set rise and run to 0 to turn off curved paths
				//rise = 0;
				//run = 0;

				smoother[1] = y(d.end[1]) - rise;
				smoother[0] = x(d.end[0]) - run;

				// To check where the smoother is located
				// rink.append("circle")
				// 	.attr("class", "smoother")
				// 	.attr("cx", smoother[0])
				// 	.attr("cy", smoother[1])
				// 	.attr("r", 2)
				// 	.attr("fill", "#ccc");
			}

			return "M" + start + " S" + smoother[0] + "," + smoother[1] + " " + end;
		})
		.style("stroke", "pink")
		.style("fill", "none");

var points = players.selectAll("circle.waypoint")
	.data(function(d) { return d.waypoints; })
	.enter().append("circle")
		.attr("class", "waypoint")
		.attr("cx", function(d) { return x(d.x); })
		.attr("cy", function(d) { return y(d.y); })
		.attr("r", 2)
		.style("fill", "pink");

var markers = players.append("g")
		.attr("class", "marker")
		.attr("transform", function(d) { return "translate(" + x(d.waypoints[0].x) + "," + y(d.waypoints[0].y) + ")"; });

var circles = markers.append("circle")
	.attr("cx", 0)
	.attr("cy", -1) // To better center circle on player number
	.attr("r", 10)
	.style("stroke", function(d) { return d.colour; })
	.style("fill", function(d) { return d.colour; })
	.style("fill-opacity", 0)
	.style("stroke-opacity", 0);

markers.append("text")
	.attr("r", 5)
	.attr("x", 0)
	.attr("y", 0)
	.style("alignment-baseline", "middle")
	.style("text-anchor", "middle")
	.style("fill", function(d) { return d.colour; })
	.text(function(d) { return d.player; });



/*
*
* Start transitions
*
*/

markers.each(function(d) {
	slide(d3.select(this), d, 0);
});

rink.append("line")
	.attr("class", "puck")
	.style("stroke", "blue")
	.style("stroke-opacity", 0)
	.style("stroke-dasharray", "2,3");
rink.append("circle")
	.attr("class", "puck")
	.attr("r", 2)
	.style("fill", "blue")
	.style("fill-opacity", 0);

setPassTimer(0);


function setPassTimer(idx) {
	setTimeout(function() {

		// Draw and remove puck path
		if (idx > 0) {
			var sourceTransform = markers.filter(function(d) { return d.player === targets[idx - 1]; }).attr("transform");
			var sourcePos = [];
			sourcePos[0] = sourceTransform.substring(sourceTransform.indexOf("(") + 1, sourceTransform.indexOf(","));
			sourcePos[1] = sourceTransform.substring(sourceTransform.indexOf(",") + 1, sourceTransform.indexOf(")"));
			sourcePos = [+sourcePos[0], +sourcePos[1]];

			var targetPos = [];
			if (targets[idx] === "r-goal" || targets[idx] === "l-goal") {
				targetPos = [x(190), y(85/2)];
			} else {
				var targetTransform = markers.filter(function(d) { return d.player === targets[idx]; }).attr("transform");
				targetPos[0] = targetTransform.substring(targetTransform.indexOf("(") + 1, targetTransform.indexOf(","));
				targetPos[1] = targetTransform.substring(targetTransform.indexOf(",") + 1, targetTransform.indexOf(")"));
				targetPos = [+targetPos[0], +targetPos[1]];
			}

			var duration = 500;
			if (targets[idx] === "r-goal" || targets[idx] === "l-goal") {
				duration = 1500;
			}

			// Draw and hide puck path
			rink.select("line.puck")
				.attr("x1", sourcePos[0])
				.attr("y1", sourcePos[1])
				.attr("x2", targetPos[0])
				.attr("y2", targetPos[1])
				.transition().duration(50)
					.style("stroke-opacity", 1)
					.transition().duration(duration)
						.style("stroke-opacity", 0);

			rink.select("circle.puck")
				.attr("cx", targetPos[0])
				.attr("cy", targetPos[1])
				.transition().duration(50)
					.style("fill-opacity", 1)
					.transition().duration(duration)
						.style("fill-opacity", 0);
		}

		circles.transition()
			.style("fill-opacity", "0")
			.style("stroke-opacity", "0");

		circles.filter(function(d) { return d.player === targets[idx]; })
			.transition()
				.style("fill-opacity", "0")
				.style("stroke-opacity", "1");

		if (idx < targets.length - 1) {
			setPassTimer(idx + 1);
		}
	}, delays[idx]);
}

function slide(element, data, idx) {

	if (idx < data.waypoints.length - 1) {
		var animPlayerGroup = d3.selectAll("g.player").filter(function(d) { return d.player === data.player; });
		var animMarker = animPlayerGroup.select("g.marker");
		var animPath = animPlayerGroup.selectAll("path").filter(function(d) { return d.order === idx; });

		animMarker.transition()
			.duration(function(d) { return d.paths[idx].duration * 1000; })
			.ease("linear")
			.attrTween("transform", translateAlong(animPath.node()))
			.each("end", function(d) {
				slide(d3.select(this), d, idx + 1);
			});
	}
}

// Returns an attrTween for translating along the specified path element.
function translateAlong(path) {
	var l = path.getTotalLength();
	return function(d, i, a) {
		return function(t) {
		  var p = path.getPointAtLength(t * l);
		  return "translate(" + p.x + "," + p.y + ")";
		};
	};
}

</script>
</html>