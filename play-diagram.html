<!DOCTYPE html>
<html lang="en" style="width: 100%; overflow-x: hidden;">
<head>
	<meta charset="utf-8">
	<title>Play Diagram</title>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
	<link href="http://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet" type="text/css">
	<script type="text/javascript" src="js/rinkPlot.js"></script>
	<link rel="stylesheet" type="text/css" href="css/style.css">
</head>
<body>
	<a href="#" id="grid-toggle" style="text-decoration: none; font-family: Roboto;">Grid</a>
	<a href="#" id="play" style="text-decoration: none; font-family: Roboto; margin-left: 20px;">Play</a>
	<svg id="rink-svg" style="display: block;"></svg>
	<div id="table" style="display: block;"></div>
	</div>
</body>
<script>
var rinkWidth = 200;
var rinkHeight = 85;
var ftPerCell = 5;
var cellSize = 20;


var pathColour = "lightskyblue"; //pink

var margin = {top: 30, left: 30, right: 30, bottom: 30};

var x = d3.scale.linear()
	.domain([0, rinkWidth])
	.range([0, (rinkWidth / ftPerCell) * cellSize]);
var y = d3.scale.linear()
	.domain([0, rinkHeight])
	.range([(rinkHeight / ftPerCell) * cellSize, 0]);

var isGridVisible = false;





// Player with puck - use -1000 or 1000 for the left and right nets
var carriers = [];
var possessionStartTimes = [];

// Store pass timer as a variable so it can be cleared if the animation is restarted midway
var passTimer;


// Prepare the data
var playerData = [];
var playerIds = d3.range(1, 10 + 1, 1);
playerIds.forEach(function(p) {
	playerData.push({
		id: p,
		label: "F" + p,
		colour: "blue",
		waypoints: [],
		paths: []
	})
});

// Timeline
var timelineWidth = 900;
var timelineHeight = 40;
var seconds = d3.range(0, 30 + 1, 1);
var tX = d3.scale.ordinal()
	.domain(seconds)
	.rangeRoundPoints([0, timelineWidth], 1);


/*
*
* Initialize svg and groups
*
*/

d3.select("#rink-svg")
	.style("height", (rinkHeight / ftPerCell) * cellSize + margin.top + margin.bottom + "px")
	.style("width", (rinkWidth / ftPerCell) * cellSize + margin.left + margin.right + "px")
	.style("margin", "20px")
	.style("background", "#fff")
	.style("font-family", "Roboto, sans-serif")
	.style("font-size", "12px")
	.style("font-weight", "500");

d3.select("#rink-svg").append("text")
	.attr("x", x.range()[1] + margin.left)
	.attr("y", y.range()[0] + margin.top)
	.style("font-size", "12px")
	.style("font-weight", "300")
	.style("fill", "#ccc")
	.style("text-anchor", "end")
	.text("@datarink");

var rink = d3.select("#rink-svg").append("g")
	.attr("id", "rink")
	.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
rink.append("g")
	.attr("id", "h-rules");
rink.append("g")
	.attr("id", "v-rules");
var rinkMap = rink.append("g")
	.attr("id", "rink-map");
rink.append("g")
	.attr("id", "players");
/*
*
* Append rink diagram and customize styling
*
*/

var drawRinkMap = new RINK_MAP({parent: rinkMap, fullRink: true, desiredWidth: (rinkHeight / ftPerCell) * cellSize, horizontal: true});
drawRinkMap();
styleRink();

appendGrid();

initTimeline();










/*
*
* Append puck marker
*
*/

rink.append("line")
	.attr("class", "puck")
	.style("stroke", "black")
	.style("stroke-opacity", 0)
	.style("stroke-dasharray", "2,3");
rink.append("circle")
	.attr("class", "puck")
	.attr("r", 2)
	.style("fill", "black")
	.style("fill-opacity", 0);

/*
*
* Start transitions
*
*/



d3.select("#play").on("click", function() {
	d3.selectAll("g.marker").each(function(d) {
		slide(d3.select(this), d, 0);
	});

	// Clear the existing passTimer before restarting the pass sequence from idx = 0
	// Also reset the circle indicating the puck carrier
	clearTimeout(passTimer);
	d3.selectAll("g.marker").selectAll("circle").style("stroke-opacity", function(d) {
		if (d.id === carriers[0]) {
			return 1;
		} else {
			return 0;
		}
	});
	setPassTimer(0);
});

function setPassTimer(idx) {
	passTimer = setTimeout(function() {

		// Draw and remove puck path
		if (idx > 0) {
			var sourceTransform = markers.filter(function(d) { return d.id === carriers[idx - 1]; }).attr("transform");
			var sourcePos = [];
			sourcePos[0] = sourceTransform.substring(sourceTransform.indexOf("(") + 1, sourceTransform.indexOf(","));
			sourcePos[1] = sourceTransform.substring(sourceTransform.indexOf(",") + 1, sourceTransform.indexOf(")"));
			sourcePos = [+sourcePos[0], +sourcePos[1]];

			var targetPos = [];
			if (carriers[idx] === 1000 || carriers[idx] === -1000) {
				targetPos = [x(190), y(85/2)];
			} else {
				var targetTransform = markers.filter(function(d) { return d.id === carriers[idx]; }).attr("transform");
				targetPos[0] = targetTransform.substring(targetTransform.indexOf("(") + 1, targetTransform.indexOf(","));
				targetPos[1] = targetTransform.substring(targetTransform.indexOf(",") + 1, targetTransform.indexOf(")"));
				targetPos = [+targetPos[0], +targetPos[1]];
			}

			var duration = 500;
			if (carriers[idx] === 1000 || carriers[idx] === -1000) {
				duration = 1500;
			}

			//Draw and hide puck path
			rink.select("line.puck")
				.attr("x1", sourcePos[0])
				.attr("y1", sourcePos[1])
				.attr("x2", targetPos[0])
				.attr("y2", targetPos[1])
				.transition().duration(50)
					.style("stroke-opacity", 1)
					.transition().duration(duration)
						.style("stroke-opacity", 0);

			rink.select("circle.puck")
				.attr("cx", targetPos[0])
				.attr("cy", targetPos[1])
				.transition().duration(50)
					.style("fill-opacity", 1)
					.transition().duration(duration)
						.style("fill-opacity", 0);
		}

		d3.selectAll("g.markers").selectAll("circle").transition()
			.style("stroke-opacity", function(d) {
				if (d.id === carriers[idx]) {
					return 1;
				} else {
					return 0;
				}
			});

		if (idx < carriers.length - 1) {
			setPassTimer(idx + 1);
		}
	}, possessionStartTimes[idx] - possessionStartTimes[idx - 1]);
}

function slide(element, data, idx) {

	if (idx < data.paths.length) {
		var animPlayerGroup = d3.selectAll("g.player").filter(function(d) { return d.id === data.id; });
		var animMarker = animPlayerGroup.select("g.marker");
		var animPath = animPlayerGroup.selectAll("path").filter(function(d) { return d.order === idx; });

		animMarker.transition()
			.duration(function(d) { return d.paths[idx].duration * 1000; })
			.ease("linear")
			.attrTween("transform", translateAlong(animPath.node()))
			.each("end", function(d) {
				slide(d3.select(this), d, idx + 1);
			});
	}
}

// Returns an attrTween for translating along the specified path element.
function translateAlong(path) {
	var l = path.getTotalLength();
	return function(d, i, a) {
		return function(t) {
		  var p = path.getPointAtLength(t * l);
		  return "translate(" + p.x + "," + p.y + ")";
		};
	};
}



function initTimeline() {

	// Create the timeline table
	var rows = d3.select("#table").selectAll("div.player.row")
		.data(playerData)
		.enter().append("div")
			.attr("id", function(d) { return "player-" + d.id; })
			.attr("class", "player row");
	rows.append("div")
		.attr("class", "player-id cell")
		.text(function(d) { return d.id; });
	rows.append("div")
		.attr("class", "label cell")
		.text(function(d) { return d.label; });
	rows.append("div")
		.attr("class", "colour cell")
		.text(function(d) { return d.colour; });
	rows.append("div")
		.attr("class", "timeline cell");

	// Append timeline svgs and timepoints
	var timelines = d3.select("#table").selectAll("div.timeline")
		.append("svg")
			.attr("height", timelineHeight + "px")
			.attr("width", timelineWidth + "px");

	// Append a circle to indicate the active timepoint or waypoint; these should be rendered behind the actual timepoints
	timelines.append("circle")
		.attr("class", "active")
		.attr("r", 8)
		.attr("cy", timelineHeight / 2)
		.style("fill", "none")
		.style("stroke", "black")
		.style("visibility", "hidden");

	var timepoints = timelines.selectAll("circle.timepoint")
		.data(seconds)
	timepoints.enter().append("circle")
		.attr("class", "timepoint")
		.attr("cy", timelineHeight / 2)
		.attr("cx", function(d) { return tX(d); })
		.attr("r", 4);
	setTimelineListeners();

	// Append a dot in the rink-svg for user to pick skater position
	// Draw the rectangle above the dot so that all mousemove events register
	d3.select("#rink").append("circle")
		.attr("id", "picker-marker")
		.attr("cx", 0)
		.attr("cy", 0)
		.attr("r", 5)
		.style("fill-opacity", 0)
		.style("visibility", "hidden");
	d3.select("#rink").append("rect")
		.attr("id", "picker-mask")
		.attr("width", x.range()[1])
		.attr("height", y.range()[0])
		.attr("rx", x(28))
		.attr("ry", y(0) - y(28))
		.style("fill-opacity", 0)
		.style("visibility", "hidden");
}

function setTimelineListeners(sourceElement) {

	if (sourceElement == null) {
		// If this function is called without a sourceElement, reset listeners
		d3.selectAll("div.timeline").selectAll("circle.timepoint, circle.waypoint").on("click", function(d) {

			var activePlayerId = this.parentNode.parentNode.parentNode.__data__.id;

			// Get the active time, which is stored differently for timepoint and waypoints
			var activeTime;
			var activeElementClass = d3.select(this).attr("class");
			if (activeElementClass.indexOf("waypoint") >= 0) {
				activeTime = d.t;
			} else if (activeElementClass.indexOf("timepoint") >= 0) {
				activeTime = d;
			}

			// Updates listeners to the timepoint or waypoint case
			highlightTimepoint(activePlayerId, activeTime);
			openPicker(activePlayerId, activeTime);
			setTimelineListeners(this);
		});
	} else {
		// If a waypoint or timepoint was initially clicked
		var sourcePlayerId = d3.select(sourceElement).node().parentNode.parentNode.parentNode.__data__.id;
		if (d3.select(sourceElement).attr("class").indexOf("waypoint") >= 0) {
			// WAYPOINT CASE: If a waypoint was initially clicked, then:
			// Clicking on a timepoint will transfer the waypoint to the clicked timepoint
			// Clicking the initial waypoint closes the picker
			// Clicking other waypoints does nothing
			d3.selectAll("div.timeline").selectAll("circle.timepoint").on("click", function(d) {
				var activePlayerId = this.parentNode.parentNode.parentNode.__data__.id;
				updateWaypoint(activePlayerId, d, sourceElement.__data__.x, sourceElement.__data__.y);
				removeWaypoint(sourcePlayerId, sourceElement.__data__.t);
				closePicker();
			});
			d3.selectAll("div.timeline").selectAll("circle.waypoint").on("click", null);
			d3.select(sourceElement).on("click", function() {
				closePicker();
			});
		} else if (d3.select(sourceElement).attr("class").indexOf("timepoint") >= 0) {
			// TIMEPOINT CASE: If a timepoint was initially clicked, then:
			// Clicking on the already-selected timepoint will cancel the picker
			// Clicking on another timepoint will change the picker to the new timepoint
			// Clicking on waypoints does nothing
			d3.selectAll("div.timeline").selectAll("circle.timepoint").on("click", function(d) {
				var activePlayerId = this.parentNode.parentNode.parentNode.__data__.id;
				if (sourcePlayerId === activePlayerId && d === sourceElement.__data__) {
					closePicker();
				} else {
					// Reset listeners based on the clicked timepoint (so that clicking on this new timepoint again will close the picker)
					setTimelineListeners(this);
					highlightTimepoint(activePlayerId, d);
					openPicker(activePlayerId, d);
				}
			});
			d3.selectAll("div.timeline").selectAll("circle.waypoint").on("click", null);
		}
	}
}

// Highlights the timepoint in the timeline of the specified player id
function highlightTimepoint(player, t) {
	d3.selectAll("div.timeline").filter(function(d) { return d.id !== player; })
		.select("circle.active")
			.style("visibility", "hidden");
	d3.selectAll("div.timeline").filter(function(d) { return d.id === player; })
		.select("circle.active")
			.attr("cx", tX(t))
			.style("visibility", "visible");
}

function openPicker(player, t) {
	// Make picker elements visible
	d3.selectAll("#picker-marker, #picker-mask")
		.style("visibility", "visible");
	d3.select("#picker-mask").transition()
		.style("fill-opacity", 0.1);
	d3.select("#picker-marker").transition()
		.style("fill-opacity", 1);

	// Move the picker marker; snap to the closest whole foot
	var pxPerFt = cellSize / ftPerCell;
	var mPos;
	var mX;
	var mY;
	d3.select("#picker-mask").on("mousemove", function() {
		mPos = d3.mouse(this);
		mX = Math.round(mPos[0] / pxPerFt) * pxPerFt;
		mY = Math.round(mPos[1] / pxPerFt) * pxPerFt;
		d3.select("#picker-marker").attr("cx", mX)
			.attr("cy", mY);
	});

	// Update waypoint data with the picked position, then close the picker
	d3.select("#picker-mask").on("click", function() {
		updateWaypoint(player, t, Math.round(x.invert(mX)), Math.round(y.invert(mY)));
		closePicker();
	});
}

// Remove listeners and hide picker
function closePicker() {
	// Hide active highlight in timelines
	d3.selectAll("div.timeline").select("circle.active")
		.style("visibility", "hidden");

	// Hide picker elements on rink
	d3.select("#picker-mask").on("mousemove", null);
	d3.select("#picker-mask").on("click", null);
	d3.selectAll("#picker-marker, #picker-mask")
		.transition()
			.style("fill-opacity", 0)
			.each("end", function() {
				d3.select(this).style("visibility", "hidden")
			});

	// Reset listeners
	setTimelineListeners();
}

function removeWaypoint(player, t) {
	var playerToUpdate = playerData.filter(function(d) { return d.id === player; })[0];

	// Check if a waypoint for the specified time already exists. If it does, get its index
	var existingWaypointIdx = -1;
	var i = 0;
	while (existingWaypointIdx < 0 && i < playerToUpdate.waypoints.length) {
		if (playerToUpdate.waypoints[i].t === t) { existingWaypointIdx = i; }
		else { i++; }
	}

	if (existingWaypointIdx >= 0) {
		playerToUpdate.waypoints.splice(existingWaypointIdx, 1);
	}

	// Update path data and rink elements
	generateDStrings(playerToUpdate.id - 1);
	updateRink();
}

function updateWaypoint(player, t, x, y) {

	var playerToUpdate = playerData.filter(function(d) { return d.id === player; })[0];

	// Check if a waypoint for the specified time already exists. If it does, get its index
	var existingWaypointIdx = -1;
	var i = 0;
	while (existingWaypointIdx < 0 && i < playerToUpdate.waypoints.length) {
		if (playerToUpdate.waypoints[i].t === t) { existingWaypointIdx = i; }
		else { i++; }
	}

	// Add or update waypoint
	if (existingWaypointIdx >= 0) {
		playerToUpdate.waypoints[existingWaypointIdx] = {t: t, x: x, y: y};
	} else {
		playerToUpdate.waypoints.push({t: t, x: x, y: y});
		playerToUpdate.waypoints = playerToUpdate.waypoints.sort(function(a, b) { return a.t - b.t; });
	}

	// Update path data and rink elements
	generateDStrings(playerToUpdate.id - 1);
	updateRink();
}

function updateRink() {

	// Append players and paths
	var players = rink.select("#players").selectAll("g.player")
		.data(playerData.filter(function(d) { return d.waypoints.length > 0; }), function(d) { return d.id; });
	players.exit().remove();
	var enteredPlayers = players.enter().append("g")
		.attr("class", "player");

	var paths = players.selectAll("path")
		.data(function(d) { return d.paths; });
	paths.exit().remove();
	paths.enter().append("path")
		.style("fill", "none");
	paths.attr("d", function(d) { return d.dString; })
		.style("stroke", pathColour);

	var points = players.selectAll("text.waypoint")
		.data(function(d) { return d.waypoints; }, function(w) { return w.t; })
	points.exit().remove();
	points.enter().append("text")
		.attr("class", "waypoint")
		.style("font-size", 10)
		.style("font-weight", 300)
		.style("text-anchor", "middle")
		.style("alignment-baseline", "middle");
	points.attr("x", function(d) { return x(d.x); })
		.attr("y", function(d) { return y(d.y); })
		.style("fill", pathColour)
		.text(function(d) { return d.t; });

	var markers = enteredPlayers.append("g")
		.attr("class", "marker");
	markers.append("circle")
		.attr("cx", 0)
		.attr("cy", -1) // To better center circle on player number
		.attr("r", 10)
		.style("stroke", "black")
		.style("fill", "none")
		.style("stroke-opacity", 0);
	markers.append("text")
		.attr("r", 5)
		.attr("x", 0)
		.attr("y", 0)
		.style("fill", function(d) { return d.colour; })
		.text(function(d) { return d.label; });

	// Update marker positions in case the first waypoint's data has changed
	d3.selectAll("g.marker")
		.attr("transform", function(d) { return "translate(" + x(d.waypoints[0].x) + "," + y(d.waypoints[0].y) + ")"; });

	/*
	*
	* Update timeline with event dots
	*
	*/

	var rows = d3.select("#table").selectAll("div.player.row")
		.data(playerData);
	var timelines = rows.select("div.timeline").select("svg");
	var waypoints = timelines.selectAll("circle.waypoint")
		.data(function(d) { return d.waypoints; }, function(w) { return w.t; });
	waypoints.exit().remove();
	waypoints.enter().append("circle")
		.attr("class", "waypoint")
		.attr("r", 5);
	waypoints.attr("cx", function(d) { return tX(d.t); })
		.attr("cy", timelineHeight / 2);
};

function generateDStrings(playerIdx) {

	// Convert waypoints to paths
	paths = [];
	for (var i = 0; i < playerData[playerIdx].waypoints.length - 1; i++) {
		var nextPoint = [];
		if (i < playerData[playerIdx].waypoints.length - 2) {
			nextPoint = [playerData[playerIdx].waypoints[i + 2].x, playerData[playerIdx].waypoints[i + 2].y];
		}

		paths.push({
			order: i,
			start: [playerData[playerIdx].waypoints[i].x, playerData[playerIdx].waypoints[i].y],
			end: [playerData[playerIdx].waypoints[i + 1].x, playerData[playerIdx].waypoints[i + 1].y],
			next: nextPoint,
			duration: playerData[playerIdx].waypoints[i + 1].t - playerData[playerIdx].waypoints[i].t
		});
	}
	playerData[playerIdx].paths = paths;

	// Create the string for each path's d attribute
	rink.selectAll("circle.ctrlPt").remove();
	for (var i = 0; i < playerData[playerIdx].paths.length; i++) {

		var ctrlPt = [x(playerData[playerIdx].paths[i].end[0]), y(playerData[playerIdx].paths[i].end[1])];

		if (playerData[playerIdx].paths[i].start[0] === playerData[playerIdx].paths[i].end[0] && playerData[playerIdx].paths[i].start[1] === playerData[playerIdx].paths[i].end[1]) {
			// Keep the ctrlPt at the endPt if the player is stationary
		} else if (playerData[playerIdx].paths[i].next.length === 2) {

			var rise = y(playerData[playerIdx].paths[i].next[1]) - y(playerData[playerIdx].paths[i].end[1]);
			rise *= -1; // Adjust rise since higher y values are plotted lower
			var run = x(playerData[playerIdx].paths[i].next[0]) - x(playerData[playerIdx].paths[i].end[0]);
			var slope = rise / run;
			var delta = 10;

			if (slope === 0) {
				if (run >= 0) {
					// If player will skate right, then ctrlPt is left
					ctrlPt[0] = ctrlPt[0] - delta;
				} else {
					// If player will skate left, then ctrlPt is right
					ctrlPt[0] = ctrlPt[0] + delta;
				}
			} else if (slope == Number.POSITIVE_INFINITY || slope == Number.NEGATIVE_INFINITY) {
				if (rise >= 0) {
					// If player skates up, then ctrlPt is down
					ctrlPt[1] = ctrlPt[1] + delta;
				} else {
					// If player skates down, then ctrlPt is up
					ctrlPt[1] = ctrlPt[1] - delta;
				}
			} else if (slope > 0) {
				if (run >= 0) {
					// If player will skate up and right, then ctrlPt is down and left
					ctrlPt[0] = ctrlPt[0] - delta;
					ctrlPt[1] = ctrlPt[1] + delta * slope;
				} else {
					// If player will skate down and left, then ctrlPt is up and right
					ctrlPt[0] = ctrlPt[0] + delta;
					ctrlPt[1] = ctrlPt[1] - delta * slope;
				}
			} else if (slope < 0) {
				if (run >= 0) {
					// If player will skate down and right, then ctrlPt is up and left; remember that slope is negative
					ctrlPt[0] = ctrlPt[0] + delta / slope;
					ctrlPt[1] = ctrlPt[1] - delta;
				} else {
					// If player will skate up and left, then ctrlPt is down and right; remember that slope is negative
					ctrlPt[0] = ctrlPt[0] - delta / slope;
					ctrlPt[1] = ctrlPt[1] + delta;
				}
			}

			// To check where the smoother is located
			rink.append("circle")
				.attr("class", "ctrlPt")
				.attr("cx", ctrlPt[0])
				.attr("cy", ctrlPt[1])
				.attr("r", 2)
				.attr("fill", "gold");
		}

		var dString = "M" + x(playerData[playerIdx].paths[i].start[0]) + "," + y(playerData[playerIdx].paths[i].start[1]);
		dString += " S" + ctrlPt[0] + "," + ctrlPt[1];
		dString += " " + x(playerData[playerIdx].paths[i].end[0]) + "," + y(playerData[playerIdx].paths[i].end[1]);
		playerData[playerIdx].paths[i].dString = dString;
	}
}

/*
*
* Updates styling from rinkPlot.js
*
*/

function styleRink() {

	// Remove translation
	rinkMap.select("g.zones")
		.attr("transform", "");

	// Make rink monochrome
	var rinkStroke = "#ccc";
	var rinkFill = "#ebebeb";
	rinkMap.select("g.zones").selectAll("rect")
		.style("fill", rinkFill)
	rinkMap.select("g.zones").selectAll("rect.red-line")
		.style("fill", rinkStroke)
	rinkMap.select("g.zones").selectAll("path, line, circle")
		.style("stroke", rinkStroke);
	rinkMap.select("g.zones").selectAll("circle.red-line")
		.style("stroke", "none")
		.style("fill", rinkFill);
	rinkMap.select("g.zones").selectAll("path.goal-crease")
		.style("stroke", rinkStroke)
		.style("fill", "none");
	rinkMap.selectAll("path.rink-face, circle.red-faceoff")
		.style("fill", "none");

	// Hide the original half rink-faces from rinkPlot.js because it has a line where the 2 halves meet
	rinkMap.selectAll(".rink-face")
		.style("stroke", "none");

	// Redraw a full rink rink-face for a neat outline
	rinkMap.select("g.zones")
		.append("rect")
			.attr("width", x.range()[1])
			.attr("height", y.range()[0])
			.attr("rx", x(28))
			.attr("ry", y(0) - y(28))
			.style("fill", "none")
			.style("stroke", rinkStroke);
}

/*
*
* Append grid
*
*/

function appendGrid() {

	// Append horizontal rules
	var gridlines = rink.select("#h-rules").selectAll("g")
		.data(d3.range(y.domain()[0], y.domain()[1] + ftPerCell, ftPerCell))
		.enter().append("g");
	gridlines.append("line")
		.attr("x1", function() { return d3.min(x.range()); })
		.attr("x2", function() { return d3.max(x.range()); })
		.attr("y1", function(d) { return y(d); })
		.attr("y2", function(d) { return y(d); });
	gridlines.append("text")
		.attr("y", function(d) { return y(d); })
		.attr("x", -10);

	// Append vertical rules
	gridlines = rink.select("#v-rules").selectAll("g")
		.data(d3.range(x.domain()[0], x.domain()[1] + ftPerCell, ftPerCell))
		.enter().append("g");
	gridlines.append("line")
		.attr("x1", function(d) { return x(d); })
		.attr("x2", function(d) { return x(d); })
		.attr("y1", function() { return d3.min(y.range()); })
		.attr("y2", function() { return d3.max(y.range()); });
	gridlines.append("text")
		.attr("y", y.range()[0] + 20)
		.attr("x", function(d) { return x(d); });

	// Apply common attributes
	rink.selectAll("#v-rules, #h-rules").selectAll("line, text")
		.attr("class", "grid");
	rink.selectAll("#v-rules, #h-rules").selectAll("text")
		.text(function(d) { return d; });

	// Set grid visibility
	if (isGridVisible) {
		rink.selectAll("#v-rules, #h-rules").selectAll("line, text")
			.style("visibility", "visible");
	} else {
		rink.selectAll("#v-rules, #h-rules").selectAll("line, text")
			.style("visibility", "hidden");
	}

	// Add listener to toggle control for grid visibility
	d3.select("#grid-toggle").on("click", function() {
		var gridElements = rink.selectAll("#v-rules, #h-rules").selectAll("line, text");
		if (isGridVisible) {
			gridElements.style("visibility", "hidden");
			isGridVisible = false;
		} else {
			gridElements.style("visibility", "visible");
			isGridVisible = true;
		}
	});
}
</script>
</html>